Entendido! Refiz o c칩digo C do m칩dulo de montagem da Torre de Fuga, removendo todos os separadores (---, ===) e mantendo a formata칞칚o o mais simples e direta poss칤vel, focada nos algoritmos e na an치lise de desempenho.

游 C칩digo C para Montagem da Torre de Fuga (Vers칚o Simples)
C

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h> 

// CONSTANTES E DEFINI칂츾O DA ESTRUTURA
#define CAPACIDADE_MAXIMA 20
#define MAX_NOME 30
#define CHAVE_BUSCA "chip central" 

// Struct Componente
struct Componente {
    char nome[MAX_NOME];
    char tipo[20];
    int prioridade;
};
typedef struct Componente Componente;

// VARI츼VEIS DE CONTROLE
Componente torre_componentes[CAPACIDADE_MAXIMA];
int totalComponentes = 0;
long long comparacoes = 0;
double tempoExecucao = 0.0;


// =================================================================
// FUN칂칏ES AUXILIARES
// =================================================================

void limparBuffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

void copiarVetor(Componente destino[], const Componente origem[], int n) {
    for (int i = 0; i < n; i++) {
        destino[i] = origem[i];
    }
}

void trocarComponentes(Componente* a, Componente* b) {
    Componente temp = *a;
    *a = *b;
    *b = temp;
}

void mostrarComponentes(const Componente lista[], int n) {
    printf("\nCOMPONENTES ATUAIS (Total: %d/%d)\n", n, CAPACIDADE_MAXIMA);
    
    if (n == 0) {
        printf("Nenhum componente cadastrado.\n");
        return;
    }

    for (int i = 0; i < n; i++) {
        printf("[%02d] | Prioridade: %02d | Tipo: %s | Nome: %s\n",
               i,
               lista[i].prioridade,
               lista[i].tipo,
               lista[i].nome);
    }
}

void cadastrarComponentes() {
    if (totalComponentes >= CAPACIDADE_MAXIMA) {
        printf("\n! Capacidade maxima de componentes (%d) atingida.\n", CAPACIDADE_MAXIMA);
        return;
    }

    Componente novo;
    printf("\nCADASTRO DE NOVO COMPONENTE\n");
    
    printf("Nome (max 29): ");
    limparBuffer(); 
    if (fgets(novo.nome, MAX_NOME, stdin) != NULL) {
        novo.nome[strcspn(novo.nome, "\n")] = 0; 
    } else {
        return;
    }
    
    printf("Tipo (ex: controle, suporte, propulsao): ");
    scanf("%19s", novo.tipo);

    printf("Prioridade (1 a 10): ");
    scanf("%d", &novo.prioridade);
    if (novo.prioridade < 1 || novo.prioridade > 10) novo.prioridade = 5; 
    
    limparBuffer(); 

    torre_componentes[totalComponentes] = novo;
    totalComponentes++;

    printf("--> Componente '%s' cadastrado com sucesso.\n", novo.nome);
}


// =================================================================
// ALGORITMOS DE ORDENA칂츾O
// =================================================================

// 1. Bubble Sort: Ordenar por NOME (String)
void bubbleSortNome(Componente lista[], int n) {
    comparacoes = 0;
    int i, j;
    int trocou;

    clock_t inicio = clock();

    for (i = 0; i < n - 1; i++) {
        trocou = 0;
        for (j = 0; j < n - i - 1; j++) {
            comparacoes++;
            if (strcmp(lista[j].nome, lista[j + 1].nome) > 0) {
                trocarComponentes(&lista[j], &lista[j + 1]);
                trocou = 1;
            }
        }
        if (trocou == 0) break;
    }

    clock_t fim = clock();
    tempoExecucao = (double)(fim - inicio) / CLOCKS_PER_SEC;
}

// 2. Insertion Sort: Ordenar por TIPO (String)
void insertionSortTipo(Componente lista[], int n) {
    comparacoes = 0;
    int i, j;
    Componente chave;

    clock_t inicio = clock();

    for (i = 1; i < n; i++) {
        chave = lista[i];
        j = i - 1;

        while (j >= 0) {
            comparacoes++;
            if (strcmp(lista[j].tipo, chave.tipo) > 0) {
                lista[j + 1] = lista[j];
                j = j - 1;
            } else {
                break;
            }
        }
        lista[j + 1] = chave;
    }

    clock_t fim = clock();
    tempoExecucao = (double)(fim - inicio) / CLOCKS_PER_SEC;
}

// 3. Selection Sort: Ordenar por PRIORIDADE (Int)
void selectionSortPrioridade(Componente lista[], int n) {
    comparacoes = 0;
    int i, j, min_idx;

    clock_t inicio = clock();

    for (i = 0; i < n - 1; i++) {
        min_idx = i;
        for (j = i + 1; j < n; j++) {
            comparacoes++;
            
            // Ordem decrescente de prioridade (maior n칰mero primeiro)
            if (lista[j].prioridade > lista[min_idx].prioridade) { 
                min_idx = j;
            }
        }
        
        trocarComponentes(&lista[min_idx], &lista[i]);
    }

    clock_t fim = clock();
    tempoExecucao = (double)(fim - inicio) / CLOCKS_PER_SEC;
}


// =================================================================
// ALGORITMOS DE BUSCA
// =================================================================

// Busca Bin치ria: Localiza o componente-chave
void buscaBinariaPorNome(const Componente lista[], int n, const char* nomeChave) {
    if (n == 0) {
        printf("\n! A lista esta vazia. Nao e possivel buscar.\n");
        return;
    }

    comparacoes = 0;
    int inicio = 0;
    int fim = n - 1;
    int encontrado = 0;
    
    printf("\nBUSCA BINARIA: Componente Chave (%s)\n", nomeChave);

    while (inicio <= fim) {
        comparacoes++;
        int meio = inicio + (fim - inicio) / 2;
        int resultado_comparacao = strcmp(lista[meio].nome, nomeChave);

        if (resultado_comparacao == 0) {
            printf("Sucesso! Componente-chave encontrado na posicao %d.\n", meio);
            printf("Nome: %s | Tipo: %s | Prioridade: %d\n",
                   lista[meio].nome, lista[meio].tipo, lista[meio].prioridade);
            encontrado = 1;
            break;
        } else if (resultado_comparacao < 0) {
            inicio = meio + 1;
        } else {
            fim = meio - 1;
        }
    }

    if (!encontrado) {
        printf("! Falha. Componente-chave '%s' nao encontrado. A torre nao pode ser ativada.\n", nomeChave);
    }
    printf("Total de comparacoes na busca: %lld\n", comparacoes);
}


// =================================================================
// BLOCO PRINCIPAL (MENU DE ESTRAT칄GIA)
// =================================================================

int main() {
    int opcao;
    Componente lista_temp[CAPACIDADE_MAXIMA]; 

    printf("MODULO DE PRIORIZACAO DA TORRE DE FUGA\n");
    printf("Componente Chave para Ativacao: %s\n", CHAVE_BUSCA);

    do {
        mostrarComponentes(torre_componentes, totalComponentes);

        printf("\nESCOLHA A ESTRATEGIA DE ORDENACAO:\n");
        printf("1. Cadastrar Componente\n");
        printf("2. Ordenar por NOME (Bubble Sort)\n");
        printf("3. Ordenar por TIPO (Insertion Sort)\n");
        printf("4. Ordenar por PRIORIDADE (Selection Sort)\n");
        printf("5. Buscar Componente-Chave (Busca Binaria - Requer Ordenacao por Nome!)\n");
        printf("0. Sair do Sistema\n");
        printf("Opcao: ");

        if (scanf("%d", &opcao) != 1) { 
            limparBuffer(); 
            opcao = -1; 
        }

        if (opcao >= 2 && opcao <= 5 && totalComponentes == 0) {
            printf("\n! Cadastre componentes antes de ordenar/buscar.\n");
            continue;
        }

        switch (opcao) {
            case 1:
                cadastrarComponentes();
                break;

            case 2:
                copiarVetor(lista_temp, torre_componentes, totalComponentes);
                bubbleSortNome(lista_temp, totalComponentes);
                mostrarComponentes(lista_temp, totalComponentes);
                printf("\nANALISE: Bubble Sort (Nome) - Comparacoes: %lld | Tempo: %.6f segundos.\n", comparacoes, tempoExecucao);
                break;

            case 3:
                copiarVetor(lista_temp, torre_componentes, totalComponentes);
                insertionSortTipo(lista_temp, totalComponentes);
                mostrarComponentes(lista_temp, totalComponentes);
                printf("\nANALISE: Insertion Sort (Tipo) - Comparacoes: %lld | Tempo: %.6f segundos.\n", comparacoes, tempoExecucao);
                break;

            case 4:
                copiarVetor(lista_temp, torre_componentes, totalComponentes);
                selectionSortPrioridade(lista_temp, totalComponentes);
                mostrarComponentes(lista_temp, totalComponentes);
                printf("\nANALISE: Selection Sort (Prioridade) - Comparacoes: %lld | Tempo: %.6f segundos.\n", comparacoes, tempoExecucao);
                break;
                
            case 5:
                // A Busca Bin치ria exige ordena칞칚o por nome
                copiarVetor(lista_temp, torre_componentes, totalComponentes);
                bubbleSortNome(lista_temp, totalComponentes); 
                printf("--> Ordenacao temporaria por nome aplicada para Busca Binaria (%.6f seg.).\n", tempoExecucao);

                buscaBinariaPorNome(lista_temp, totalComponentes, CHAVE_BUSCA);
                break;

            case 0:
                printf("\nSistema de Montagem da Torre encerrado.\n");
                break;
                
            default:
                printf("\n! Opcao invalida. Tente novamente.\n");
        }
        
    } while (opcao != 0);

    return 0;
}
